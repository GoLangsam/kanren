// package vari provides a tiny factory
// for named and anonymous variables.
//
//
package vari

import "strconv"

// able - a factory for variables: `vari.Able` (pun intended)
//
//   vars vari.Able = vari.Ables()
//   u := vars.Fresh("my Name")
//   v := vars.V() // anonymous
//
type Able struct {
	pool
}

func Ables() Able {
	return Able{newPool()}
}

// pool represents the variables seen so far
type pool struct {
	seen map[string]V
}

func newPool() pool {
	return pool{
		seen: make(map[string]V),
	}
}

/*
func (v V) String() string {
	return "<lvar " + v.Name + strconv.Itoa(int(v.index)) + ">"
}
*/

// V returns a fresh variable (with an autogenerated name)
func (p *pool) V() V {
	return p.Fresh("~." + strconv.Itoa(len(p.seen)))
}

// Fresh returns a fresh variable
// (and updates the internal pool).
func (p *pool) Fresh(name string) V {

	_, known := p.seen[name]
	if known {
		panic("Fresh: duplicate name for variable")
	}

	x := newVar(name)
	v := x.Atom.Var
	p.seen[name] = v

	return v
}
