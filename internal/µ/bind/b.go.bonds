package bind

type bond int

// Bind represents bindings: any logic variable may be bound to some symbolic expression
// representing the current value of such variable.
type Bind struct {
	bound map[V]bond // Variables bound via bond to one of the bonds
	bonds map[bond]X // bonds map (via bond) to the expression representing the current value.
	count int
}

func New() *Bind {
	return &Bind{
		bound: make(map[V]bond),
		bonds: make(map[bond]X),
	}
}

/* see Subs below
func (b *Bind) Val_at(v V) (X, bool) {
	bond, found := b.bound[v]
	if found {
		t, isBound := b.bonds[bond]
		return t, isBound
	}
	return nil, false
}
*/

// Clone provides a clone of b.
func (b *Bind) Clone() *Bind {
	clone := New()
	copy(clone.bound.b.bound)
	copy(clone.bonds.b.bonds)
	clone.count = b.count
	return clone
}

// Bind binds x to v, so v is bound to x.
// Thus, (v . x) resembles a substitution pair.
// Note: Bind does not avoid circular bindings
func (b *Bind) Bind(v V, x X) *Bind {

	bond := bond(b.count)
	b.bound[v] = bond
	b.bonds[bond] = x
	b.count++
	return b
}

// Drop makes v unbound.
// A existing Bind (if any) is discarded.
func (b *Bind) Drop(v V) {
	bond, isBound := b.bound[v]
	if isBound {
		delete(b.bonds, bond)
		delete(b.bound, v)
	}
}

// IsBound reports whether v is bound or not
func (b *Bind) IsBound(v V) (isBound bool) {
	_, isBound = b.bound[v]
	return
}

// Subs return the expression to which v is bound, if any.
func (b *Bind) Subs(v V) (x X, hasSubs bool) {
	bond, hasSubs := b.bound[v]
	if hasSubs {
		x, hasSubs = b.bonds[bond]
	}
	return
}

// vAsX returns a singleton expression composed only of v
func (b *Bind) vAsX(v V) (x X) {
	// TODO: ast-Magic
	return
}

// walk ...
func (b *Bind) walk(v V) X {
	x, ok := b.Subs(v)
	if !ok {
		return b.vAsX(v)
	}
	if !x.IsVariable() {
		return x
	}
	return b.walk(x.Atom.Var)
}

// Walk ...
func (b *Bind) Walk(x X) X {
	xx := x
	if x.IsVariable() {
		xx = b.walk(x.Atom.Var)
	}
	if xx.IsVariable() {
		return xx
	}
	if xx.IsPair() {
		return Cons(
			b.Walk(xx.Pair.Car),
			b.Walk(xx.Pair.Cdr),
		)
	}
	return xx
}

// occurs reports whether v occurs in x.
func (b *Bind) occurs(v V, x X) bool {
	xx := x
	if x.IsVariable() {
		xx = b.walk(x.Atom.Var)
	}
	if xx.IsVariable() {
		return xx.Atom.Var.Equal(v)
	}
	if xx.IsPair() {
		return b.occurs(v, xx.Car()) || b.occurs(v, xx.Cdr())
	}
	return false
}

// exts attempts to bind v with x and fails
// if such bind would introduce a circle
// due to v occurs in x.
func (b *Bind) exts(v V, x X) bool {
	if b.occurs(v, x) {
		return false
	}
	b.Bind(v, x)
	// append([]*Substitution{&Substitution{Var: v.Name, Value: x}}, s...), true
	return true

}

// Unify returns either (ok = false) or the substitutions extended with zero or more associations,
// where cycles in substitutions can lead to (ok = false)
func (b *Bind) Unify(x, y X) bool {
	xx := x
	if x.IsVariable() {
		xx = b.walk(x.Atom.Var)
	}
	yy := y
	if y.IsVariable() {
		yy = b.walk(y.Atom.Var)
	}

	if xx.IsVariable() && yy.IsVariable() && xx.Atom.Var.Equal(xx.Atom.Var) {
		return true
	}

	if xx.IsVariable() {
		return b.exts(xx.Atom.Var, yy)
	}
	if yy.IsVariable() {
		return b.exts(yy.Atom.Var, xx)
	}

	if xx.IsPair() && yy.IsPair() {
		sok := b.Unify(xx.Car(), yy.Car())
		if !sok {
			return false
		}
		return b.Unify(xx.Cdr(), yy.Cdr())
	}
	if xx.Equal(yy) {
		return true
	}
	return false
}

// Reify ...
func (b *Bind) Reify(x X) *Bind {
	xx := x
	if x.IsVariable() {
		xx = b.walk(x.Atom.Var)
	}
	if xx.IsVariable() {
		return b.Bind(xx.Atom.Var, NewSymbol("_"+strconv.Itoa(len(b.bound))))
	}
	if xx.IsPair() {
		return b.Reify(xx.Car()).Reify(xx.Cdr())
	}
	return b
}
